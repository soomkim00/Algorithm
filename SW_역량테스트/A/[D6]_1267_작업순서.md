# 접근
## 1 DFS -> 재귀 호출을 사용한 접근

- 가장 상위 정점을 count를 이용해 구함
- 상위 정점들부터 dfs를 호출하여서 진행
- dfs
	1. 부모 정점들을 조사해서 방문 경험이 있는지를 체크
	2. 방문하지 않았다면 부모 정점으로 다시 dfs 호출
	3. 부모 정점 모두 방문했다면(혹은 없다면) 해당 정점 방문 확인
	4. 방문 안했으면 방문 리스트 추가
	5. 해당 정점 자식 정점들에 대해서 dfs 호출
- 작은 case 문제는 해결.. 규모가 커지니 재귀 깊이 초과로 인한 error
- 부모 정점들과 자식 정점들을 dfs를 호출할 때 함수 해결 없이 연속적으로 호출해서
- 규모가 큰 경우 호출 스텍이 과하게 중첩

<br/>

## 사실 이 문제는 dfs가 아닌 bfs문제..
- 왜 dfs로 풀었는가?
- 문제 소개 카테고리에 dfs라 되있어서..
- 문제 풀기 전에 유형을 잘 파악하자 ^^

<br/>

## 2. BFS -> queue(deque)를 사용한 접근

### 2-1. 최상위 정점부터 순서대로!
- count를 이용해 부모 정점이 없는 최상위 정점들을 구해서
- 큐에 추가
- 이후 큐가 비지 않는 동안 하나씩 pop하면서 (popleft)
- 나온 원소들의 자식 정점들을 큐에 추가 (중복 체크 후)
- 계속 반복하면.. 하나씩 밑으로 내려가지 않나???
결과 : 테스트케이스 반만 통과! why???

### 2-2. 부모 정점의 개수를 확인하자!
- GPT o3-mini-high의 도움을 받아..
- 단순히 자식 정점만 추가하게 되면 처리되지 않는 중간 정점 발생
- ex.한 정점에 깊이가 다른 자식 정점이 존재하는 경우
- 따라서, 한 정점을 제거할때마다 연결된 자식 정점들의 부모 수를 줄여주고
- 그 결과 부모 정점 개수가 0인 자식만 큐에 추가!