# 0~K(목표 합) 까지의 수를 만들어 낼 수 있는 경우의 수를 각각 기록하자
# sequence: 원본 배열 수 중 하나씩을 골라가면서 테이블을 최신화
# 0을 만들어 낼 수 있는 경우의 수는 {} 하나 이기에 dp[0]은 1
# 그 이후 숫자 seq[i]를 하나씩 꺼내가면서 역순 순회하며 업데이트하는데
# ** 숫자 합 j를 만들어 낼 수 있는 경우의 수 == j - seq[i]를 만들어 낼 수 있는 경우의 수
# ex. seq[i] == 2 일 때, 숫자 합 2를 만들어 낼 수 있는 경우의 수는 0을 만들어 낼 수 있는 경우의 수와 같다
#       0에다가 2를 더하면 2가 되니까..
# 숫자 하나씩 가져오면서 해당 방법으로 끝에서 하나씩 업데이트해서 숫자를 다 사용한 후에
# 최종 숫자 K를 만드는 경우의 수인 dq[k]를 출력

T = int(input())

for tc in range(1, T + 1):
    N, K = map(int, input().split())
    sequence = list(map(int, input().split()))
    cnt = 0

    # dp[j]: 수열 요소들을 조합하여 정확히 합이 j가 되는 경우의 수
    dp = [0] * (K + 1)
    # dp[0] = 1: 공집합->합이 되는 경우의 수 1가지
    dp[0] = 1
    # 인덱스를 증가시키면서 seq 수 하나씩에 대해서
    for i in range(N):
        # j: K 부터 seq[i]까지 역순 순회
        # 각 원소를 한 번만 사용하기 위해
        for j in range(K, sequence[i] - 1, -1):
            # j 를 만들기 위한 경우의 수 = j-seq[i]를 만들기 위한 경우의 수
            # 왜? j-seq[i]에 seq[i]를 더하면 되니까!..ㅎㅎ
            dp[j] += dp[j - sequence[i]]
    # 원하는 cnt == 합이 K가 되는경우의 수 == dp[K]
    cnt = dp[K]
    print(f"#{tc} {cnt}")
